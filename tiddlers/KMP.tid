created: 20220103061127315
creator: 邱桥
modified: 20220103124645993
modifier: 邱桥
tags: 算法
title: KMP
tmap.id: 8316f6db-c82a-46bc-ac92-c5b72703bb5a
type: text/vnd.tiddlywiki

KMP是一种复杂度为O(m+n)的字符串匹配算法，其中m，n分别为两个字符串的长度。

!! 原理
!!! 传统方法(Brute-Force法)是挨个比较，匹配失败则后移一个字符继续比较。
[img[v2-1892c7f6bee02e0fc7baf22aaef7151f_1440w.png]]

!!! 考虑改进：每次失配之后，移很多位，跳过那些不可能匹配成功的位置

!!! 要移到哪里呢？

上一次部分匹配成功的主串的后缀，与模式串的前缀一致时，有可能匹配得上（如果不一致，那就肯定没法匹配上了）！所以可以把模式串移到前缀与后缀重合。

如：
[img[v2-67dd66b86323d3d08f976589cf712a1a_1440w.png]]

上次匹配成功部分：abc__''ab''__

模式串：__''ab''__cabd

可以移到ab重合，即向右移(m-next)次，m是匹配成功的前缀长度，''定义next是前缀、后缀重合的最长长度（最长公共前后缀），但不能等于m''，不然就无法移动了。特别地，(m-next)==0时，应右边移一位

!!! 怎么知道上一次部分匹配成功的主串的后缀？

部分匹配成功的主串的后缀，必然是模式串的一个前缀，且这个前缀是上一次匹配成功的部分：

[img[v2-7dc61b0836af61e302d9474eeeecfe83_1440w.png]]

!!! 岂不是每次匹配都要计算一次要移多少位？

不需要。既然部分匹配成功的主串的后缀，必然是模式串的一个前缀，那么只需要计算出所有前缀对应的next值，然后保存在数组里就可以了。然后可以按照匹配前缀的长度，直接从数组中寻找对应的next值。

[img[v2-d6c6d433813595dce5aad08b40dc0b72_1440w.png]]

!!! 快速求出next数组
核心思想是''“P自己与自己做匹配”''。

!!! 采用递推的方式：
设模式串为P，令now=next[x-1]

# next[0]=0
#*因为该前缀的长度为0，所以公共前后缀长度为0
# 若P[x]=P[now]，则next[x]=now+1[img[v2-6d6a40331cd9e44bfccd27ac5a764618_1440w.png]]
# 若P[x]$$\ne$$P[now]，考虑缩短now，再尝试扩展，循环往复直到扩展成功（P[now]=P[x]）或者没有公共前后缀（公共前后缀长度为0）[img[v2-ce1d46a1e3603b07a13789b6ece6022f_1440w.png]]
#*now缩短多少呢？显然，根据next的定义，字串A等于字串B时，才有可能满足条件。由于缩短前的字串A等于字串B，“缩到字串A等于字串B”相当于求子串A的公共后缀长度，根据next的定义，也就是''next[now-1]''


